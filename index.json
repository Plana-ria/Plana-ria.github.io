[{
    "title": "クリップボードの共有機能を実装",
    "date": "",
    "description": "Unity + WebGLでクリップボードの共有機能を実装しました．",
    "body": "経緯 Unity + WebGLでクリップボードを使おうとしたところ，GUIUtility.systemCopyBuffer はUnity独自のクリップボードを使っているようで，通常のクリップボードとの連携ができませんでした．\n調べてみると，WebGLInputパッケージなどを使うとInputFieldではコピペできるようですが，私の環境では 上手く動作しませんでした．\nそこで，クリップボードの共有機能を自作することにしました．\n概要 構造としてはこんな感じで実装します．\n Unity側のクリップボードを監視し，コピーされたら通常のクリップボードに上書きする処理 通常のクリップボードを監視し，コピーされたらUnity側のクリップボードに上書きする処理  実装方法 まずは，Unityでの処理を書いていきます．\nCopyPaste.cs using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using System.Runtime.InteropServices; public class CopyPaste : MonoBehaviour { #if UNITY_WEBGL \u0026amp;\u0026amp; !UNITY_EDITOR //コピー [DllImport(\u0026quot;__Internal\u0026quot;)] private static extern void CopyWebGL(string str); //ペースト [DllImport(\u0026quot;__Internal\u0026quot;)] private static extern void PasteWeb(); private string unityClip; private string webClip; void Start() { unityClip = \u0026quot;\u0026quot;; webClip = \u0026quot;\u0026quot;; PasteWeb(); } void Update() { if(GUIUtility.systemCopyBuffer != unityClip){ unityClip = GUIUtility.systemCopyBuffer; CopyWebGL(unityClip); Debug.Log(\u0026quot;Copy unity to clip\u0026quot;); } PasteWeb(); } public void paste(string text){ if(text != webClip){ webClip = text; GUIUtility.systemCopyBuffer = webClip; } } #else #endif }  これを適当なゲームオブジェクトに張り付けておきます．\n次にPluginsフォルダに以下のCopyWebGL.jslib ファイルを作成します．\nCopyWebGL.jslib mergeInto(LibraryManager.library, { CopyWebGL: function(str) { if(navigator.clipboard){ navigator.clipboard.writeText(str) //httpでは使えない(httpsのみ) .then(function(text){ }); }else{ var str = Pointer_stringify(str); var listener = function(e){ e.clipboardData.setData(\u0026quot;text/plain\u0026quot; , str); e.preventDefault(); document.removeEventListener(\u0026quot;copy\u0026quot;, listener); } document.addEventListener(\u0026quot;copy\u0026quot; , listener); document.execCommand(\u0026quot;copy\u0026quot;); } }, PasteWeb: function() { if(navigator.clipboard){ navigator.clipboard.readText() .then(function(text){ SendMessage('CopyPaste', 'paste', text); //クリップボードから取得したテキストを渡す（ゲームオブジェクト名，メソッド名，クリップボードの値） }); } } });  これでクリップボードの共有ができるようになりました． あとは，普通にGUIUtility.systemCopyBufferを 使えばUnity外部ともコピペできます．\n所感 コピペは問題なくできますが，Webページのロード時にクリップボード へのアクセス許可が必要になってしまいました．\nセキュリティ的な問題だと思いますので，早く公式の方で直感的にクリップボードが 使える機能を実装してほしいものです\u0026hellip;\n",
    "ref": "/blog/unity2dgame/02/"
  },{
    "title": "セーブ・ロード機能の実装",
    "date": "",
    "description": "Unity + WebGLでSQLサーバにセーブデータを保存する機能を実装しました．",
    "body": "経緯 わけあって，Unityでブラウザゲームを制作することになったのですが， 依頼主からセーブ・ロード機能が欲しいと言われました．\nとりあえず調べてみると，PlayerPrefsあたりが使えるみたいですが， ローカル保存ではなくサーバ保存にしたいとのこと．\nさらに調べてみると，ゲームアツマールに投稿すればAPIを使ってサーバに セーブできるらしいのですが，ニコニコアカウント必須なのはNGで， ゲーム自体も依頼主のホームページに置きたいそうなので却下．\n結局，SQLサーバに保存する機能を自作することにしました．\n概要 とはいえ，実装する構造自体はシンプルです．\n Unityからセーブデータをサーバに送る処理 送られたセーブデータをデータベースに登録する処理 セーブデータをデータベースから読み込んでUnityに送る処理 Unityで受けっとたセーブデータをゲームに反映する処理  こんな感じでしょうか？\nとりあえず，サーバ側でセーブ・ロードするAPIを書いて， UnityでPostすれば良さそうです．\nセーブ・ロードAPI まずは，データベースとの接続処理を書きます．\nconnect.php \u0026lt;?php //MySQL接続 function connectDB(){ //ユーザ名・DBアドレス $dsn = 'mysql:dbname=XXXXXXX; host=XXX.XXX.XXX.XXX; charset=utf8'; $username = 'XXXX'; $password = 'XXXX'; try { $pdo = new PDO($dsn, $username, $password); } catch (PDOException $e) { exit('' . $e-\u0026gt;getMessage()); } return $pdo; } ?\u0026gt;  次に，セーブ用の処理をPHPで書いていきます．\nsave.php \u0026lt;?php require_once('connect.php'); //connect.phpを使ってデータベースに接続する $pdo = connectDB(); $table = \u0026quot;XXX\u0026quot;; //DBのテーブル名 //POST受け取り $id = $_POST[\u0026quot;id\u0026quot;]; //ユーザのid $no = $_POST[\u0026quot;no\u0026quot;]; //セーブファイルの番号 $json = $_POST[\u0026quot;json\u0026quot;]; //json形式のセーブデータ if($no != \u0026quot;\u0026quot;){ try { $stmt = $pdo-\u0026gt;prepare(\u0026quot;INSERT INTO $table (id, no, json) VALUES ( :id, :no, :json ) ON DUPLICATE KEY UPDATE json = :json\u0026quot;); $stmt-\u0026gt;bindValue(':id', $id, PDO::PARAM_STR); $stmt-\u0026gt;bindValue(':no', $no, PDO::PARAM_STR); $stmt-\u0026gt;bindValue(':time', $json, PDO::PARAM_STR); $stmt-\u0026gt;execute(); } catch (PDOException $e) { var_dump($e-\u0026gt;getMessage()); } } $pdo = null; //DB切断 $res = \u0026quot;NG\u0026quot;; if($stmt) $res = \u0026quot;OK\u0026quot;; echo $res; //結果を表示 ?\u0026gt;  ここでは，ユーザIDとセーブファイルの番号をデータベースの主キーとして， セーブデータはjson形式で保存します．データベースでは以下のようなテーブルを 用意しておきます．\n   id no json     ユーザID セーブファイル番号 セーブデータ    この3つのデータはPostで受け取る様にしておきます．\n同様に，ロード用の処理も書きます．\nload.php \u0026lt;?php require_once('connect.php'); //connect.phpを使ってデータベースに接続する $pdo = connectDB(); $table = \u0026quot;XXX\u0026quot;; //DBのテーブル名 //POST受け取り $id = $_POST[\u0026quot;id\u0026quot;]; //要求されてくるユーザのid try { $stmt = $pdo-\u0026gt;prepare(\u0026quot;SELECT * FROM $table WHERE `id` = :id\u0026quot;); $stmt-\u0026gt;bindValue(':id', $id, PDO::PARAM_STR); $log = $stmt; $stmt-\u0026gt;execute(); //ここの処理は適宜変更する(！一度連想配列にしてからjsonにした方がきれい！) $res = '{\u0026quot;id\u0026quot;:\u0026quot;'; $res2 = '\u0026quot;,\u0026quot;data\u0026quot;:['; foreach ($stmt as $row) { //今回はただカラムを指定し、出力された文字列を結合して出力 $getid = $row['id']; $res2 = $res2. '{\u0026quot;no\u0026quot;:\u0026quot;'; $res2 = $res2. $row['no']; $res2 = $res2. '\u0026quot;,\u0026quot;json\u0026quot;:\u0026quot;'; $res2 = $res2. $row['json']; $res2 = $res2. '\u0026quot;},'; } if($id != $getid) $id = \u0026quot;NoSuchIDError!\u0026quot;; $res = $res. $id; $res = $res. $res2; $res = rtrim($res,','); $res = $res. ']}'; } catch (PDOException $e) { $res = '{\u0026quot;id\u0026quot;:\u0026quot;SQLError!\u0026quot;,\u0026quot;data\u0026quot;:[]}'; } $pdo = null; //DB切断 echo $res; //unity に結果を返す ?\u0026gt;  こちらは，ユーザIDをPostで受け取るとすべてのセーブデータをjson形式で返しています．\nUnity側の処理 あとは，UnityにてPost処理を書きます．ここではwwwを使っていますが，できれば新しい方の UnityWebRequestsを使いましょう．\nPost処理 Dictionary\u0026lt;string, string\u0026gt; dic = new Dictionary\u0026lt;string, string\u0026gt;(); //Postするデータ dic.Add(\u0026quot;id\u0026quot;, id); dic.Add(\u0026quot;no\u0026quot;, no); dic.Add(\u0026quot;json\u0026quot;, json); private IEnumerator Post(string uri, Dictionary\u0026lt;string, string\u0026gt; post) { WWWForm form = new WWWForm(); foreach (KeyValuePair\u0026lt;string, string\u0026gt; post_arg in post) { form.AddField(post_arg.Key, post_arg.Value); } WWW www = new WWW(uri, form); yield return StartCoroutine(CheckTimeOut(www, 3f)); //3sでタイムアウト; if (www.error != null) { Debug.Log(\u0026quot;Post Error: \u0026quot; + www.error); //そもそも接続ができていないとき } else if (www.isDone) { //接続に成功した時 //送られてきたデータ(www.text)をテキスト表示 Debug.Log(www.text); /*以下で適宜セーブのチェックやロード処理を書く * * * */ } }  このPostはこんな感じで\nStartCoroutine(Post(URI, dic));  使いたいところでコルーチンを開始させます．\n所感 思ったより簡単に実装することは出来ましたが，普通にめんどくさいので 特別な理由がなければ，PlayerPrefsかゲームアツマールAPIを使いましょう．\n",
    "ref": "/blog/unity2dgame/01/"
  }]
